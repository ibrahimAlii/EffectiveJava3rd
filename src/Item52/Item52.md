# استخدم تعددية الدوال بتروّي - Use overloading judiciously 

البرنامج التالي مكتوب بحسن نية بحيث يصنف\يعنون الشيئ بناء على نوعه.

```java
// معطوب! - ماذا يطبع هذا البرنامج؟
public class CollectionClassifier {
    public static String classify(Set<?> s){
        return "مجموعة";
    }
    
    public static String classify(List<?> lst){
        return "متسلسلة";
    }
    
    public static String classify(Collection<?> c){
        return "مجموعة غير معروفة";
    }
    
    public static void main(String[] args){
        Collection<?>[] collections = {new HashSet<String>(), 
        new ArrayList<BigInteger>(), new HashMap<String, String>()};
        
        for (Collection<?> c: collections) {
            System.out.println(classify(c));
        }
    }
}
```

لعلك تتوقع أن هذا البرنامج سيقوم بطابعة "مجموعة" ثم "متسلسلة" ثم "مجموعة غير معروفة"؛ لكن هذا غير صحيح لأن هذا البرنامج سيطبع "مجموعة غير معروفة" ثلاث مرات! **لماذا حدث هذا؟** لأن دالة التصنيف معددة؛ **واختيار الدالة التي سيتم استدعائها يتم في وقت تحويل الأكواد (كومبايل)**؛؛ طريقة عمل هذا البرنامج حدسية لأن **اختيار الدوال المعددة ثابت، بينما الاختيار بناءً عن الإبدال حيوي (ديناميكي).\
النسخة السليمة من هذا البرنامج يتم كتابتها بطريقة الإبدال بالاعتماد على هذه الطريقة؛ فإنها تعمل في وقت التشغيل بطريقة حيوية (ديناميكية)**؛ مثال:

```java
class Juice {
    String name() {return "عصير";}
}

class OrangeJuice extends Juice {
    @Override String name() {return "عصير برتفال";}
}
class LimonJuice extends Juice {
    @Override String name() {return "عصير ليمون";}
}

public class Overriding{
    public static void main(String[] args){
        List<Juice> juiceList = List.of(new Juice(), new OrangeJuice(), new LimonJuice());
        
        for (Juice juice : juiceList) {
            System.out.println(juice.name());
        }
    }
}
```

الدالة المسماة "إسم" تم تعرفيها في "كلاس" عصير الرئيسي وتمت وراثاتها في الكلاسات الفرعية كل على حدى؛\
وكما تتوقع أن هذا البرنامج سيقوم بطباعة "عصير" ثم "عصير برتقال" ثم "عصير ليمون"

في المثال الأول كانت النية هي تمييز نوع المدخلات عن طريقة استخدام الدالة المناسبة كما فعلنا في الدالة السابقة "اسم" حيث تم تحديد الاسم في وثت التشغل وليس في وقت ترجمة الأكواد؛ لذلك أفضل طريقة لحل مشكلة المثال الأول هي عن طريق تفقد نوعية الكلاس باستخدام دالة ثابتة\ساكنة:

```java
public static String classify(Collection<?> c){
    return c instanceof Set ? "مجموعة" : c instanceof List ? "متسلسلة" : "محموعة غير معروفة";
}
```

اختصاراً للحديث؛ ينبغي ألا تستخدم نفس اسم الدالة بأنواع مدخلات مختلفة؛ يمكنك دائما استخدام اسماء دوال أخرى بدلا من تعددية الدوال؛ فعلى سبيل المثال كلاس:\
`ObjectOutputStream`\
يحوي هذا الكلاس مجموعة دالة لكل نوع من أنواع البيانات البدائية مثل:\
`writeBoolean(boolean)`, `writeInt(int)` and `writeLong(long)` -- `readInt()`, `readLong()` etc...



في دوال البناء لا نملك خيار الأسماء المتعددة؛ لكننا نملك خيار الدوال الثابتة ([راجع الموضوع رقم 1](https://github.com/ibrahimAlii/EffectiveJava3rd/tree/master/src/Item01))


بداية من اصدار الجافا الخامس؛ كل القيم البدائية مختلفين تمام عن القيم المرجعية؛ لكن هذا ليس صحيح في حضور القيم المغلفة، وأحدث هذا مشاكل فعلية؛ فخذ المثال التالي:

```java
public class SetList {
    public static void main(String[] args) {
        Set<Integer> set = new TreeSet<>();
        List<Integer> list = new ArrayList<>();
        
        for(int i = -3; i < 3; i++) {
          set.add(i);
          list.add(i);
        }
        
        for(int i = 0; i < 3; i++) {
          set.remove(i);
          list.remove(i);
        }
        
        System.out.println(set + "  " + list);
    }
}
```

بداية البرنامج يقوم بإضافة القيم من -3 إلى 2 للمجموعة وللمتسلسة أيضا؛ ثم يتم إزالة ثلاث عناصر على التوالي؛\
لو كنت مثل معظم الناس تظن أن البرنامج سيقوم بإزالة القيم الموجبة وسيقوم بطباعة القيم\
[-3, -2, -1][-3, -2, -1]\
في الحقيقة هذا ليس صحيحا، إذ أن البرنامج سيقوم بإازالة القيم الموجبة في الموجموعة والقيم الفردية في المتسلسلة والناتج\
[-3, -2, -1][-2, 0, 2]\
لا شك أن هناك ارتباك في الفهم الآن.

**ماذا يحدث؟**:\
استدعاء دالة الإزالة في المجموعة تختار الدالة المتعددة لإزالة العنصر نفسه؛ بينما في المتسلسلة يتم إزالة العنصر المواقق للمكان المدخل ولحل هذه المشكلة:\
```java
for (int i = 0; i < 3; i++){
    set.remove(i);
    list.remove((Integer) i) // or remove(Integer.valueOf(i));
}
```


## الملخص :
**ليس لكونك قادراً على استخدام "تعددية الدوال" يعنى أنه يجب أن تستخدمها.\
انه من الأفضل بشكل عام الإستغناء عن تعددية الدوال في حالة وجود دوال تحمل نفس عدد المدخلات والوظيفة.\
في بعض الحالات، وبالأخص في وجود دوال البناء؛ ربما يكون من المستحيل اتباع هذه النصيحة.\
في هذه الحالات ينبغي عليك على الأقل تجنب المواقف التي تحمل فيها الدالة نفس عدد المدخلات.\
إذا لم تستطع تجنب هذه المشكلة لكونك تعدل في "كلاس" لإضافة واجهة جديدة أو ما شابه، ينبغي عليك التأكد أن جميع الدوال معددة مثماثلة عند تمرير نفس المدخلات.\
إذا فشلت في هذا سيكون من الصعب على المبرمجين تفهم طريقة عمل البرنامج وسيعانون من الكثير من المشاكل.**